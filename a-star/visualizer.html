<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* æ¼”ç®—æ³•ï¼šå¾åŸç†åˆ°å¯¦è¸</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --accent-color: #3498db;
            --bg-light: #f8f9fa;
            --text-color: #333;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: var(--text-color);
            background-color: #fff;
        }

        /* --- Header Section --- */
        header {
            background: linear-gradient(135deg, #2c3e50, #4a69bd);
            color: white;
            padding: 60px 20px;
            text-align: center;
        }

        header h1 { margin: 0; font-size: 2.5rem; }
        header p { font-size: 1.2rem; opacity: 0.9; margin-top: 10px; }

        /* --- Content Containers --- */
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        section { margin-bottom: 60px; }
        h2 { color: var(--primary-color); border-bottom: 3px solid var(--accent-color); display: inline-block; padding-bottom: 5px; margin-bottom: 20px; }
        
        /* --- Theory Section --- */
        .theory-box {
            background: var(--bg-light);
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }
        .formula {
            font-size: 1.5rem;
            text-align: center;
            font-weight: bold;
            color: var(--accent-color);
            margin: 20px 0;
            padding: 15px;
            background: white;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        ul.features li { margin-bottom: 10px; }

        /* --- Visualizer Section --- */
        #visualizer-section {
            text-align: center;
            background-color: #f0f4f8; /* ç¨å¾®å€éš”èƒŒæ™¯ */
            padding-top: 40px;
            padding-bottom: 40px;
        }

        .viz-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 25px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        button:active { transform: scale(0.95); }

        .btn-start { background-color: #27ae60; color: white; }
        .btn-start:hover { background-color: #219150; box-shadow: 0 4px 10px rgba(39, 174, 96, 0.3); }
        .btn-reset { background-color: #e74c3c; color: white; }
        .btn-reset:hover { background-color: #c0392b; box-shadow: 0 4px 10px rgba(231, 76, 60, 0.3); }

        .legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            font-size: 0.9rem;
        }
        .legend-item { display: flex; align-items: center; }
        .box { width: 12px; height: 12px; margin-right: 5px; border: 1px solid #999; }

        canvas {
            background: white;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            max-width: 100%;
            cursor: crosshair;
        }
        
        .status-text {
            margin-top: 15px;
            font-weight: bold;
            font-size: 1.1rem;
            color: #555;
            height: 25px; /* å›ºå®šé«˜åº¦é¿å…è·³å‹• */
        }

        /* --- Game Link Section --- */
        .game-cta {
            text-align: center;
            padding: 60px 20px;
            background: #2c3e50;
            color: white;
            border-radius: 15px;
            margin-bottom: 40px;
        }
        .game-cta h2 { color: white; border-color: white; }
        .btn-game {
            display: inline-block;
            margin-top: 20px;
            padding: 15px 40px;
            background: var(--accent-color);
            color: white;
            text-decoration: none;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: 0.3s;
        }
        .btn-game:hover {
            background: #2980b9;
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
        }

        /* Responsive for Canvas */
        @media (max-width: 768px) {
            .formula { font-size: 1.2rem; }
            canvas { width: 100%; height: auto; }
        }
    </style>
</head>
<body>

    <header>
        <h1>A* Pathfinding Algorithm</h1>
        <p>æ¢ç´¢éŠæˆ²é–‹ç™¼èˆ‡ AI æœ€ç¶“å…¸çš„å°‹è·¯æ¼”ç®—æ³•</p>
    </header>

    <div class="container">
        <section id="theory">
            <h2>1. ä»€éº¼æ˜¯ A* æ¼”ç®—æ³•ï¼Ÿ</h2>
            <div class="theory-box">
                <p>A* (A-Star) ç™¼è¡¨æ–¼ 1968 å¹´ï¼Œè¢«èªç‚ºæ˜¯ç›®å‰æœ€æµè¡Œçš„å°‹è·¯æ¼”ç®—æ³•ã€‚å®ƒçµåˆäº† Dijkstra æ¼”ç®—æ³•ï¼ˆä¿è­‰æœ€çŸ­è·¯å¾‘ï¼‰èˆ‡è²ªå©ªæœ€ä½³å„ªå…ˆæœå°‹ï¼ˆGreedy Best-First Searchï¼Œæœå°‹é€Ÿåº¦å¿«ï¼‰çš„å„ªé»ã€‚</p>
                <p>å®ƒçš„æ ¸å¿ƒæ©Ÿåˆ¶åœ¨æ–¼ç‚ºæ¯ä¸€å€‹æ ¼å­è¨ˆç®—ä¸€å€‹è©•åˆ† <strong>F</strong>ï¼Œæ¼”ç®—æ³•ç¸½æ˜¯å„ªå…ˆé¸æ“‡ F å€¼æœ€ä½çš„æ ¼å­é€²è¡Œæ¢ç´¢ã€‚</p>
                
                <div class="formula">F(n) = G(n) + H(n)</div>
                
                <ul class="features">
                    <li><strong>G(n) - å¯¦éš›ä»£åƒ¹ï¼š</strong> å¾èµ·é»èµ°åˆ°ç›®å‰æ ¼å­çš„æ­¥æ•¸ï¼ˆå·²çŸ¥æˆæœ¬ï¼‰ã€‚</li>
                    <li><strong>H(n) - å•Ÿç™¼ä»£åƒ¹ï¼š</strong> é ä¼°å¾ç›®å‰æ ¼å­èµ°åˆ°çµ‚é»çš„è·é›¢ï¼ˆæœªçŸ¥æˆæœ¬ï¼Œé€šå¸¸ç”¨ç›´ç·šè·é›¢ä¼°ç®—ï¼‰ã€‚</li>
                    <li><strong>F(n) - ç¸½è©•ä¼°ï¼š</strong> çµåˆå…©è€…ï¼Œæ—¢è€ƒæ…®ã€Œå·²ç¶“èµ°äº†å¤šé ã€ï¼Œä¹Ÿè€ƒæ…®ã€Œé›¢ç›®æ¨™é‚„æœ‰å¤šé ã€ã€‚</li>
                </ul>
            </div>
        </section>
    </div>

    <section id="visualizer-section">
        <div class="container">
            <h2>2. æ¼”ç®—æ³•è¦–è¦ºåŒ–æ¼”ç¤º</h2>
            <p>è«‹é»æ“Šä¸‹æ–¹ç•«å¸ƒç¹ªè£½é»‘è‰²ç‰†å£ï¼Œç„¶å¾ŒæŒ‰ä¸‹é–‹å§‹ã€‚è§€å¯Ÿæ•¸å­—è®ŠåŒ–ï¼š</p>
            
            <div class="legend">
                <div class="legend-item"><div class="box" style="background:green;"></div> èµ·é»</div>
                <div class="legend-item"><div class="box" style="background:red;"></div> çµ‚é»</div>
                <div class="legend-item"><div class="box" style="background:rgba(0, 255, 0, 0.3);"></div> è€ƒæ…®ä¸­ (Open)</div>
                <div class="legend-item"><div class="box" style="background:rgba(255, 0, 0, 0.2);"></div> å·²æª¢æŸ¥ (Closed)</div>
                <div class="legend-item"><div class="box" style="background:#3498db;"></div> æœ€ä½³è·¯å¾‘</div>
            </div>

            <div class="viz-controls">
                <button class="btn-start" onclick="startPathfinding()">â–¶ é–‹å§‹è¨ˆç®—</button>
                <button class="btn-reset" onclick="resetGrid()">â†º æ¸…é™¤/é‡ç½®</button>
            </div>

            <canvas id="gridCanvas"></canvas>
            <div class="status-text" id="statusText">æº–å‚™å°±ç·’</div>
        </div>
    </section>

    <div class="container">
        <section id="game-link">
            <div class="game-cta">
                <h2>3. å¯¦éš›æ‡‰ç”¨é«”é©—</h2>
                <p>ç†è§£åŸç†å¾Œï¼Œè®“æˆ‘å€‘çœ‹çœ‹ A* å¦‚ä½•æ‡‰ç”¨åœ¨éŠæˆ²ä¸­çš„æ•µäºº AI ä¸Šã€‚</p>
                <p>åœ¨ä¸‹é¢é€™å€‹å°éŠæˆ²ä¸­ï¼Œæ®­å±æœƒä½¿ç”¨ A* æ¼”ç®—æ³•å³æ™‚è¨ˆç®—è·¯å¾‘ä¾†è¿½è¹¤ä½ ï¼Œå³ä½¿æœ‰ç‰†å£é˜»æ“‹ä¹Ÿèƒ½æ‰¾åˆ°è·¯ã€‚</p>
                <a href="game.html" class="btn-game">ğŸ® è©¦ç©ï¼šæ®­å±è¿½è¹¤è€… (Game Demo)</a>
            </div>
        </section>
    </div>

<script>
    // --- A* Visualizer Logic (Integrated) ---
    
    // è¨­å®šåƒæ•¸
    const cellSize = 40; // ç¨å¾®ç¸®å°ä»¥é©æ‡‰æ‰‹æ©Ÿç›´å‘
    let cols = 18;
    let rows = 12;
    
    // éŸ¿æ‡‰å¼èª¿æ•´ç¶²æ ¼æ•¸é‡
    if (window.innerWidth < 800) {
        cols = 10;
        rows = 12;
    }

    const canvas = document.getElementById('gridCanvas');
    const ctx = canvas.getContext('2d');
    const statusText = document.getElementById('statusText');

    canvas.width = cols * cellSize;
    canvas.height = rows * cellSize;

    let grid = [];
    let openSet = [];
    let closedSet = [];
    let start, end;
    let path = [];
    let isFinished = false;
    let isRunning = false;
    let animationSpeed = 50;

    class Spot {
        constructor(i, j) {
            this.i = i;
            this.j = j;
            this.f = 0;
            this.g = 0;
            this.h = 0;
            this.neighbors = [];
            this.previous = undefined;
            this.wall = false;
            
            // éš¨æ©Ÿç‰†å£
            if (Math.random() < 0.15) this.wall = true;
        }

        show(color, isPath = false) {
            const x = this.i * cellSize;
            const y = this.j * cellSize;

            if (this.wall) {
                ctx.fillStyle = '#333';
                ctx.fillRect(x, y, cellSize, cellSize);
                return;
            } else if (color) {
                ctx.fillStyle = color;
                ctx.fillRect(x, y, cellSize, cellSize);
            } else {
                ctx.fillStyle = '#fff';
                ctx.fillRect(x, y, cellSize, cellSize);
            }
            
            ctx.strokeStyle = '#e0e0e0';
            ctx.strokeRect(x, y, cellSize, cellSize);

            // é¡¯ç¤ºæ•¸å­— (G, H, F)
            if (this.f > 0 || this === start || this === end) {
                ctx.fillStyle = (isPath || this === start || this === end) ? '#fff' : '#000';
                
                // ç°¡åŒ–é¡¯ç¤ºï¼šåªåœ¨è¢å¹•å¤ å¤§æ™‚é¡¯ç¤ºè©³ç´°æ•¸æ“šï¼Œæ‰‹æ©Ÿç‰ˆå¯èƒ½å¤ªæ“ 
                // é€™è£¡æˆ‘å€‘ç¨å¾®èª¿æ•´å­—é«”å¤§å°
                ctx.font = '8px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(this.g, x + 2, y + 10); // G

                ctx.textAlign = 'right';
                ctx.fillText(this.h, x + cellSize - 2, y + 10); // H

                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.f, x + cellSize / 2, y + cellSize / 2 + 5); // F
            }
        }

        addNeighbors(grid) {
            let i = this.i;
            let j = this.j;
            if (i < cols - 1) this.neighbors.push(grid[i + 1][j]);
            if (i > 0) this.neighbors.push(grid[i - 1][j]);
            if (j < rows - 1) this.neighbors.push(grid[i][j + 1]);
            if (j > 0) this.neighbors.push(grid[i][j - 1]);
        }
    }

    function init() {
        grid = new Array(cols);
        for (let i = 0; i < cols; i++) {
            grid[i] = new Array(rows);
            for (let j = 0; j < rows; j++) {
                grid[i][j] = new Spot(i, j);
            }
        }
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                grid[i][j].addNeighbors(grid);
            }
        }
        
        start = grid[0][0];
        end = grid[cols - 1][rows - 1];
        start.wall = false;
        end.wall = false;

        openSet = [start];
        closedSet = [];
        path = [];
        isFinished = false;
        isRunning = false;
        statusText.innerText = "æº–å‚™å°±ç·’ï¼šè«‹é»æ“Šç‰†å£æˆ–æŒ‰é–‹å§‹";
        statusText.style.color = "#555";
        draw();
    }

    function heuristic(a, b) {
        return Math.abs(a.i - b.i) + Math.abs(a.j - b.j);
    }

    function startPathfinding() {
        if (isRunning || isFinished) return;
        isRunning = true;
        statusText.innerText = "è¨ˆç®—ä¸­...";
        statusText.style.color = "#d35400";
        
        const loop = setInterval(() => {
            if (openSet.length > 0) {
                let winner = 0;
                for (let i = 0; i < openSet.length; i++) {
                    if (openSet[i].f < openSet[winner].f) {
                        winner = i;
                    } else if (openSet[i].f == openSet[winner].f) {
                        if (openSet[i].h < openSet[winner].h) {
                            winner = i;
                        }
                    }
                }
                let current = openSet[winner];

                if (current === end) {
                    clearInterval(loop);
                    isFinished = true;
                    isRunning = false;
                    reconstructPath(current);
                    draw();
                    statusText.innerText = `æˆåŠŸæ‰¾åˆ°è·¯å¾‘ï¼(æ­¥æ•¸: ${path.length})`;
                    statusText.style.color = "green";
                    return;
                }

                openSet.splice(winner, 1);
                closedSet.push(current);

                let neighbors = current.neighbors;
                for (let i = 0; i < neighbors.length; i++) {
                    let neighbor = neighbors[i];
                    if (!closedSet.includes(neighbor) && !neighbor.wall) {
                        let tempG = current.g + 1;
                        let newPath = false;
                        if (openSet.includes(neighbor)) {
                            if (tempG < neighbor.g) {
                                neighbor.g = tempG;
                                newPath = true;
                            }
                        } else {
                            neighbor.g = tempG;
                            newPath = true;
                            openSet.push(neighbor);
                        }
                        if (newPath) {
                            neighbor.h = heuristic(neighbor, end);
                            neighbor.f = neighbor.g + neighbor.h;
                            neighbor.previous = current;
                        }
                    }
                }
            } else {
                console.log("No solution");
                clearInterval(loop);
                isFinished = true;
                isRunning = false;
                statusText.innerText = "ç„¡è§£ï¼šç„¡æ³•æŠµé”çµ‚é»";
                statusText.style.color = "red";
                draw();
                return;
            }
            
            // å‹•ç•«éç¨‹ä¸­çš„è·¯å¾‘é è¦½
            if(!isFinished) {
                 let tempPathNode = openSet.length > 0 ? openSet[0] : null; 
                 if(closedSet.length > 0) tempPathNode = closedSet[closedSet.length-1];
                 reconstructPath(tempPathNode);
            }
            draw();
        }, animationSpeed);
    }

    function reconstructPath(current) {
        path = [];
        let temp = current;
        if(!temp) return;
        path.push(temp);
        while (temp.previous) {
            path.push(temp.previous);
            temp = temp.previous;
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                grid[i][j].show();
            }
        }
        for (let i = 0; i < closedSet.length; i++) {
            closedSet[i].show('rgba(255, 0, 0, 0.2)');
        }
        for (let i = 0; i < openSet.length; i++) {
            openSet[i].show('rgba(0, 255, 0, 0.3)');
        }
        for (let i = 0; i < path.length; i++) {
            path[i].show('#3498db', true);
        }
        start.show('#27ae60', true);
        end.show('#c0392b', true);
    }
    
    canvas.addEventListener('mousedown', (e) => {
        if (isRunning) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const i = Math.floor(x / cellSize);
        const j = Math.floor(y / cellSize);
        if (i >= 0 && i < cols && j >= 0 && j < rows) {
            if (grid[i][j] !== start && grid[i][j] !== end) {
                grid[i][j].wall = !grid[i][j].wall;
                if(isFinished) init(); else draw();
            }
        }
    });

    function resetGrid() {
        init();
    }

    // åˆå§‹åŒ–
    init();

</script>
</body>
</html>