<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* æ¼”ç®—æ³•ï¼šå¾åŸç†åˆ°å¯¦è¸</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --accent-color: #3498db;
            --bg-light: #f8f9fa;
            --text-color: #333;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: var(--text-color);
            background-color: #fff;
        }

        /* --- Header Section --- */
        header {
            background: linear-gradient(135deg, #2c3e50, #4a69bd);
            color: white;
            padding: 60px 20px;
            text-align: center;
        }

        header h1 { margin: 0; font-size: 2.5rem; }
        header p { font-size: 1.2rem; opacity: 0.9; margin-top: 10px; }

        /* --- Content Containers --- */
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        section { margin-bottom: 60px; }
        h2 { color: var(--primary-color); border-bottom: 3px solid var(--accent-color); display: inline-block; padding-bottom: 5px; margin-bottom: 20px; }
        
        /* --- Theory Section --- */
        .theory-box {
            background: var(--bg-light);
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }
        .formula {
            font-size: 1.5rem;
            text-align: center;
            font-weight: bold;
            color: var(--accent-color);
            margin: 20px 0;
            padding: 15px;
            background: white;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        ul.features li { margin-bottom: 10px; }

        /* --- Visualizer Section --- */
        #visualizer-section {
            text-align: center;
            background-color: #f0f4f8; /* ç¨å¾®å€éš”èƒŒæ™¯ */
            padding-top: 40px;
            padding-bottom: 40px;
        }

        .viz-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 25px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        button:active { transform: scale(0.95); }

        .btn-start { background-color: #27ae60; color: white; }
        .btn-start:hover { background-color: #219150; box-shadow: 0 4px 10px rgba(39, 174, 96, 0.3); }
        .btn-reset { background-color: #e74c3c; color: white; }
        .btn-reset:hover { background-color: #c0392b; box-shadow: 0 4px 10px rgba(231, 76, 60, 0.3); }

        .legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            font-size: 0.9rem;
        }
        .legend-item { display: flex; align-items: center; }
        .box { width: 12px; height: 12px; margin-right: 5px; border: 1px solid #999; }

        canvas {
            background: white;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            max-width: 100%;
            cursor: crosshair;
        }
        
        .status-text {
            margin-top: 15px;
            font-weight: bold;
            font-size: 1.1rem;
            color: #555;
            height: 25px; /* å›ºå®šé«˜åº¦é¿å…è·³å‹• */
        }

        /* --- Game Link Section --- */
        .game-cta {
            text-align: center;
            padding: 60px 20px;
            background: #2c3e50;
            color: white;
            border-radius: 15px;
            margin-bottom: 40px;
        }
        .game-cta h2 { color: white; border-color: white; }
        .btn-game {
            display: inline-block;
            margin-top: 20px;
            padding: 15px 40px;
            background: var(--accent-color);
            color: white;
            text-decoration: none;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: 0.3s;
        }
        .btn-game:hover {
            background: #2980b9;
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
        }

        /* --- Code Display Section --- */
        .code-section {
            background: var(--bg-light);
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            margin-bottom: 30px;
        }

        .code-block {
            background: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            margin: 15px 0;
        }

        .code-block pre {
            margin: 0;
            white-space: pre;
            tab-size: 4;
        }

        .code-block code {
            font-family: inherit;
        }

        .code-block .keyword { color: #c678dd; }
        .code-block .function { color: #61afef; }
        .code-block .string { color: #98c379; }
        .code-block .comment { color: #5c6370; font-style: italic; }
        .code-block .number { color: #d19a66; }
        .code-block .variable { color: #e06c75; }

        .code-explanation {
            margin-top: 15px;
            padding-left: 15px;
            border-left: 4px solid var(--accent-color);
        }

        /* Responsive for Canvas */
        @media (max-width: 768px) {
            .formula { font-size: 1.2rem; }
            canvas { width: 100%; height: auto; }
            .code-block { font-size: 0.8rem; padding: 15px; }
        }
    </style>
</head>
<body>

    <header>
        <h1>A* Pathfinding Algorithm</h1>
        <p>æ¢ç´¢éŠæˆ²é–‹ç™¼èˆ‡ AI æœ€ç¶“å…¸çš„å°‹è·¯æ¼”ç®—æ³•</p>
    </header>

    <div class="container">
        <section id="theory">
            <h2>1. ä»€éº¼æ˜¯ A* æ¼”ç®—æ³•ï¼Ÿ</h2>
            <div class="theory-box">
                <p>A* (A-Star) ç™¼è¡¨æ–¼ 1968 å¹´ï¼Œè¢«èªç‚ºæ˜¯ç›®å‰æœ€æµè¡Œçš„å°‹è·¯æ¼”ç®—æ³•ã€‚å®ƒçµåˆäº† Dijkstra æ¼”ç®—æ³•ï¼ˆä¿è­‰æœ€çŸ­è·¯å¾‘ï¼‰èˆ‡è²ªå©ªæœ€ä½³å„ªå…ˆæœå°‹ï¼ˆGreedy Best-First Searchï¼Œæœå°‹é€Ÿåº¦å¿«ï¼‰çš„å„ªé»ã€‚</p>
                <p>å®ƒçš„æ ¸å¿ƒæ©Ÿåˆ¶åœ¨æ–¼ç‚ºæ¯ä¸€å€‹æ ¼å­è¨ˆç®—ä¸€å€‹è©•åˆ† <strong>F</strong>ï¼Œæ¼”ç®—æ³•ç¸½æ˜¯å„ªå…ˆé¸æ“‡ F å€¼æœ€ä½çš„æ ¼å­é€²è¡Œæ¢ç´¢ã€‚</p>
                
                <div class="formula">F(n) = G(n) + H(n)</div>
                
                <ul class="features">
                    <li><strong>G(n) - å¯¦éš›ä»£åƒ¹ï¼š</strong> å¾èµ·é»èµ°åˆ°ç›®å‰æ ¼å­çš„æ­¥æ•¸ï¼ˆå·²çŸ¥æˆæœ¬ï¼‰ã€‚</li>
                    <li><strong>H(n) - å•Ÿç™¼ä»£åƒ¹ï¼š</strong> é ä¼°å¾ç›®å‰æ ¼å­èµ°åˆ°çµ‚é»çš„è·é›¢ï¼ˆæœªçŸ¥æˆæœ¬ï¼Œé€šå¸¸ç”¨ç›´ç·šè·é›¢ä¼°ç®—ï¼‰ã€‚</li>
                    <li><strong>F(n) - ç¸½è©•ä¼°ï¼š</strong> çµåˆå…©è€…ï¼Œæ—¢è€ƒæ…®ã€Œå·²ç¶“èµ°äº†å¤šé ã€ï¼Œä¹Ÿè€ƒæ…®ã€Œé›¢ç›®æ¨™é‚„æœ‰å¤šé ã€ã€‚</li>
                </ul>
            </div>
        </section>

        <section id="code-example">
            <h2>2. A* æ¼”ç®—æ³•æ ¸å¿ƒç¨‹å¼ç¢¼</h2>
            <div class="code-section">
                <p>ä»¥ä¸‹æ˜¯ A* æ¼”ç®—æ³•çš„ JavaScript å¯¦ä½œï¼Œå±•ç¤ºäº†å¦‚ä½•è¨ˆç®—æœ€ä½³è·¯å¾‘ï¼š</p>

<pre class="code-block"><code><span class="keyword">function</span> <span class="function">aStar</span>(start, end, grid) {
    <span class="comment">// åˆå§‹åŒ– Open Set å’Œ Closed Set</span>
    <span class="keyword">let</span> openSet = [start];
    <span class="keyword">let</span> closedSet = [];

    <span class="comment">// é–‹å§‹æœå°‹å¾ªç’°</span>
    <span class="keyword">while</span> (openSet.length > <span class="number">0</span>) {
        <span class="comment">// 1. å¾ Open Set ä¸­æ‰¾å‡º F å€¼æœ€å°çš„ç¯€é»</span>
        <span class="keyword">let</span> winner = <span class="number">0</span>;
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; openSet.length; i++) {
            <span class="keyword">if</span> (openSet[i].<span class="variable">f</span> &lt; openSet[winner].<span class="variable">f</span>) {
                winner = i;
            }
        }
        <span class="keyword">let</span> current = openSet[winner];

        <span class="comment">// 2. æª¢æŸ¥æ˜¯å¦åˆ°é”çµ‚é»</span>
        <span class="keyword">if</span> (current === end) {
            <span class="keyword">return</span> <span class="function">reconstructPath</span>(current);
        }

        <span class="comment">// 3. å°‡ç•¶å‰ç¯€é»å¾ Open Set ç§»è‡³ Closed Set</span>
        openSet.<span class="function">splice</span>(winner, <span class="number">1</span>);
        closedSet.<span class="function">push</span>(current);

        <span class="comment">// 4. æª¢æŸ¥æ‰€æœ‰é„°å±…ç¯€é»</span>
        <span class="keyword">let</span> neighbors = current.<span class="variable">neighbors</span>;
        <span class="keyword">for</span> (<span class="keyword">let</span> neighbor <span class="keyword">of</span> neighbors) {
            <span class="comment">// è·³éå·²æª¢æŸ¥çš„ç¯€é»å’Œç‰†å£</span>
            <span class="keyword">if</span> (closedSet.<span class="function">includes</span>(neighbor) || neighbor.<span class="variable">wall</span>) {
                <span class="keyword">continue</span>;
            }

            <span class="comment">// è¨ˆç®—å¾èµ·é»åˆ°æ­¤é„°å±…çš„æˆæœ¬</span>
            <span class="keyword">let</span> tempG = current.<span class="variable">g</span> + <span class="number">1</span>;

            <span class="comment">// å¦‚æœæ‰¾åˆ°æ›´å¥½çš„è·¯å¾‘ï¼Œæ›´æ–°è©²ç¯€é»</span>
            <span class="keyword">if</span> (!openSet.<span class="function">includes</span>(neighbor)) {
                openSet.<span class="function">push</span>(neighbor);
            } <span class="keyword">else if</span> (tempG &gt;= neighbor.<span class="variable">g</span>) {
                <span class="keyword">continue</span>;
            }

            <span class="comment">// æ›´æ–°ç¯€é»çš„ Gã€Hã€F å€¼</span>
            neighbor.<span class="variable">g</span> = tempG;
            neighbor.<span class="variable">h</span> = <span class="function">heuristic</span>(neighbor, end);
            neighbor.<span class="variable">f</span> = neighbor.<span class="variable">g</span> + neighbor.<span class="variable">h</span>;
            neighbor.<span class="variable">previous</span> = current;
        }
    }

    <span class="comment">// å¦‚æœ Open Set ç‚ºç©ºï¼Œè¡¨ç¤ºç„¡è§£</span>
    <span class="keyword">return</span> <span class="keyword">null</span>;
}

<span class="comment">// å•Ÿç™¼å‡½æ•¸ï¼šè¨ˆç®—å…©é»é–“çš„æ›¼å“ˆé “è·é›¢</span>
<span class="keyword">function</span> <span class="function">heuristic</span>(a, b) {
    <span class="keyword">return</span> Math.<span class="function">abs</span>(a.<span class="variable">i</span> - b.<span class="variable">i</span>) + Math.<span class="function">abs</span>(a.<span class="variable">j</span> - b.<span class="variable">j</span>);
}</code></pre>

                <div class="code-explanation">
                    <h3>ç¨‹å¼ç¢¼é‡é»èªªæ˜ï¼š</h3>
                    <ul class="features">
                        <li><strong>Open Setï¼š</strong>å­˜æ”¾å¾…è©•ä¼°çš„ç¯€é»ï¼Œæ¯æ¬¡é¸æ“‡ F å€¼æœ€å°çš„ç¯€é»é€²è¡Œæ¢ç´¢ã€‚</li>
                        <li><strong>Closed Setï¼š</strong>å­˜æ”¾å·²ç¶“è©•ä¼°éçš„ç¯€é»ï¼Œé¿å…é‡è¤‡æª¢æŸ¥ã€‚</li>
                        <li><strong>G å€¼è¨ˆç®—ï¼š</strong>å¾èµ·é»èµ°åˆ°ç•¶å‰ç¯€é»çš„å¯¦éš›æ­¥æ•¸ï¼ˆæ¯æ­¥ +1ï¼‰ã€‚</li>
                        <li><strong>H å€¼è¨ˆç®—ï¼š</strong>ä½¿ç”¨æ›¼å“ˆé “è·é›¢ï¼ˆManhattan Distanceï¼‰ä½œç‚ºå•Ÿç™¼å‡½æ•¸ï¼Œé ä¼°åˆ°çµ‚é»çš„è·é›¢ã€‚</li>
                        <li><strong>F å€¼ï¼š</strong>F = G + Hï¼Œç”¨æ–¼æ±ºå®šå„ªå…ˆæ¢ç´¢å“ªå€‹ç¯€é»ã€‚</li>
                        <li><strong>è·¯å¾‘é‡å»ºï¼š</strong>é€éæ¯å€‹ç¯€é»çš„ <code>previous</code> å±¬æ€§å›æº¯ï¼Œå»ºç«‹å®Œæ•´è·¯å¾‘ã€‚</li>
                    </ul>
                </div>
            </div>
        </section>
    </div>

    <section id="visualizer-section">
        <div class="container">
            <h2>3. æ¼”ç®—æ³•è¦–è¦ºåŒ–æ¼”ç¤º</h2>
            <p>è«‹é»æ“Šä¸‹æ–¹ç•«å¸ƒç¹ªè£½é»‘è‰²ç‰†å£ï¼Œç„¶å¾ŒæŒ‰ä¸‹é–‹å§‹ã€‚è§€å¯Ÿæ•¸å­—è®ŠåŒ–ï¼š</p>
            
            <div class="legend">
                <div class="legend-item"><div class="box" style="background:green;"></div> èµ·é»</div>
                <div class="legend-item"><div class="box" style="background:red;"></div> çµ‚é»</div>
                <div class="legend-item"><div class="box" style="background:rgba(0, 255, 0, 0.3);"></div> è€ƒæ…®ä¸­ (Open)</div>
                <div class="legend-item"><div class="box" style="background:rgba(255, 0, 0, 0.2);"></div> å·²æª¢æŸ¥ (Closed)</div>
                <div class="legend-item"><div class="box" style="background:#3498db;"></div> æœ€ä½³è·¯å¾‘</div>
            </div>

            <div class="viz-controls">
                <button class="btn-start" onclick="startPathfinding()">â–¶ é–‹å§‹è¨ˆç®—</button>
                <button class="btn-reset" onclick="resetGrid()">â†º æ¸…é™¤/é‡ç½®</button>
            </div>

            <canvas id="gridCanvas"></canvas>
            <div class="status-text" id="statusText">æº–å‚™å°±ç·’</div>
        </div>
    </section>

    <div class="container">
        <section id="game-link">
            <div class="game-cta">
                <h2>4. å¯¦éš›æ‡‰ç”¨é«”é©—</h2>
                <p>ç†è§£åŸç†å¾Œï¼Œè®“æˆ‘å€‘çœ‹çœ‹ A* å¦‚ä½•æ‡‰ç”¨åœ¨éŠæˆ²ä¸­çš„æ•µäºº AI ä¸Šã€‚</p>
                <p>åœ¨ä¸‹é¢é€™å€‹å°éŠæˆ²ä¸­ï¼Œæ®­å±æœƒä½¿ç”¨ A* æ¼”ç®—æ³•å³æ™‚è¨ˆç®—è·¯å¾‘ä¾†è¿½è¹¤ä½ ï¼Œå³ä½¿æœ‰ç‰†å£é˜»æ“‹ä¹Ÿèƒ½æ‰¾åˆ°è·¯ã€‚</p>
                <a href="game.html" class="btn-game">ğŸ® è©¦ç©ï¼šæ®­å±è¿½è¹¤è€… (Game Demo)</a>
            </div>
        </section>
    </div>

<script>
    // --- A* Visualizer Logic (Integrated) ---
    
    // è¨­å®šåƒæ•¸
    const cellSize = 40; // ç¨å¾®ç¸®å°ä»¥é©æ‡‰æ‰‹æ©Ÿç›´å‘
    let cols = 18;
    let rows = 12;
    
    // éŸ¿æ‡‰å¼èª¿æ•´ç¶²æ ¼æ•¸é‡
    if (window.innerWidth < 800) {
        cols = 10;
        rows = 12;
    }

    const canvas = document.getElementById('gridCanvas');
    const ctx = canvas.getContext('2d');
    const statusText = document.getElementById('statusText');

    canvas.width = cols * cellSize;
    canvas.height = rows * cellSize;

    let grid = [];
    let openSet = [];
    let closedSet = [];
    let start, end;
    let path = [];
    let isFinished = false;
    let isRunning = false;
    let animationSpeed = 50;

    class Spot {
        constructor(i, j) {
            this.i = i;
            this.j = j;
            this.f = 0;
            this.g = 0;
            this.h = 0;
            this.neighbors = [];
            this.previous = undefined;
            this.wall = false;
            
            // éš¨æ©Ÿç‰†å£
            if (Math.random() < 0.15) this.wall = true;
        }

        show(color, isPath = false) {
            const x = this.i * cellSize;
            const y = this.j * cellSize;

            if (this.wall) {
                ctx.fillStyle = '#333';
                ctx.fillRect(x, y, cellSize, cellSize);
                return;
            } else if (color) {
                ctx.fillStyle = color;
                ctx.fillRect(x, y, cellSize, cellSize);
            } else {
                ctx.fillStyle = '#fff';
                ctx.fillRect(x, y, cellSize, cellSize);
            }
            
            ctx.strokeStyle = '#e0e0e0';
            ctx.strokeRect(x, y, cellSize, cellSize);

            // é¡¯ç¤ºæ•¸å­— (G, H, F)
            if (this.f > 0 || this === start || this === end) {
                ctx.fillStyle = (isPath || this === start || this === end) ? '#fff' : '#000';
                
                // ç°¡åŒ–é¡¯ç¤ºï¼šåªåœ¨è¢å¹•å¤ å¤§æ™‚é¡¯ç¤ºè©³ç´°æ•¸æ“šï¼Œæ‰‹æ©Ÿç‰ˆå¯èƒ½å¤ªæ“ 
                // é€™è£¡æˆ‘å€‘ç¨å¾®èª¿æ•´å­—é«”å¤§å°
                ctx.font = '8px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(this.g, x + 2, y + 10); // G

                ctx.textAlign = 'right';
                ctx.fillText(this.h, x + cellSize - 2, y + 10); // H

                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.f, x + cellSize / 2, y + cellSize / 2 + 5); // F
            }
        }

        addNeighbors(grid) {
            let i = this.i;
            let j = this.j;
            if (i < cols - 1) this.neighbors.push(grid[i + 1][j]);
            if (i > 0) this.neighbors.push(grid[i - 1][j]);
            if (j < rows - 1) this.neighbors.push(grid[i][j + 1]);
            if (j > 0) this.neighbors.push(grid[i][j - 1]);
        }
    }

    function init() {
        grid = new Array(cols);
        for (let i = 0; i < cols; i++) {
            grid[i] = new Array(rows);
            for (let j = 0; j < rows; j++) {
                grid[i][j] = new Spot(i, j);
            }
        }
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                grid[i][j].addNeighbors(grid);
            }
        }
        
        start = grid[0][0];
        end = grid[cols - 1][rows - 1];
        start.wall = false;
        end.wall = false;

        openSet = [start];
        closedSet = [];
        path = [];
        isFinished = false;
        isRunning = false;
        statusText.innerText = "æº–å‚™å°±ç·’ï¼šè«‹é»æ“Šç‰†å£æˆ–æŒ‰é–‹å§‹";
        statusText.style.color = "#555";
        draw();
    }

    function heuristic(a, b) {
        return Math.abs(a.i - b.i) + Math.abs(a.j - b.j);
    }

    function startPathfinding() {
        if (isRunning || isFinished) return;
        isRunning = true;
        statusText.innerText = "è¨ˆç®—ä¸­...";
        statusText.style.color = "#d35400";
        
        const loop = setInterval(() => {
            if (openSet.length > 0) {
                let winner = 0;
                for (let i = 0; i < openSet.length; i++) {
                    if (openSet[i].f < openSet[winner].f) {
                        winner = i;
                    } else if (openSet[i].f == openSet[winner].f) {
                        if (openSet[i].h < openSet[winner].h) {
                            winner = i;
                        }
                    }
                }
                let current = openSet[winner];

                if (current === end) {
                    clearInterval(loop);
                    isFinished = true;
                    isRunning = false;
                    reconstructPath(current);
                    draw();
                    statusText.innerText = `æˆåŠŸæ‰¾åˆ°è·¯å¾‘ï¼(æ­¥æ•¸: ${path.length})`;
                    statusText.style.color = "green";
                    return;
                }

                openSet.splice(winner, 1);
                closedSet.push(current);

                let neighbors = current.neighbors;
                for (let i = 0; i < neighbors.length; i++) {
                    let neighbor = neighbors[i];
                    if (!closedSet.includes(neighbor) && !neighbor.wall) {
                        let tempG = current.g + 1;
                        let newPath = false;
                        if (openSet.includes(neighbor)) {
                            if (tempG < neighbor.g) {
                                neighbor.g = tempG;
                                newPath = true;
                            }
                        } else {
                            neighbor.g = tempG;
                            newPath = true;
                            openSet.push(neighbor);
                        }
                        if (newPath) {
                            neighbor.h = heuristic(neighbor, end);
                            neighbor.f = neighbor.g + neighbor.h;
                            neighbor.previous = current;
                        }
                    }
                }
            } else {
                console.log("No solution");
                clearInterval(loop);
                isFinished = true;
                isRunning = false;
                statusText.innerText = "ç„¡è§£ï¼šç„¡æ³•æŠµé”çµ‚é»";
                statusText.style.color = "red";
                draw();
                return;
            }
            
            // å‹•ç•«éç¨‹ä¸­çš„è·¯å¾‘é è¦½
            if(!isFinished) {
                 let tempPathNode = openSet.length > 0 ? openSet[0] : null; 
                 if(closedSet.length > 0) tempPathNode = closedSet[closedSet.length-1];
                 reconstructPath(tempPathNode);
            }
            draw();
        }, animationSpeed);
    }

    function reconstructPath(current) {
        path = [];
        let temp = current;
        if(!temp) return;
        path.push(temp);
        while (temp.previous) {
            path.push(temp.previous);
            temp = temp.previous;
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                grid[i][j].show();
            }
        }
        for (let i = 0; i < closedSet.length; i++) {
            closedSet[i].show('rgba(255, 0, 0, 0.2)');
        }
        for (let i = 0; i < openSet.length; i++) {
            openSet[i].show('rgba(0, 255, 0, 0.3)');
        }
        for (let i = 0; i < path.length; i++) {
            path[i].show('#3498db', true);
        }
        start.show('#27ae60', true);
        end.show('#c0392b', true);
    }
    
    canvas.addEventListener('mousedown', (e) => {
        if (isRunning) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const i = Math.floor(x / cellSize);
        const j = Math.floor(y / cellSize);
        if (i >= 0 && i < cols && j >= 0 && j < rows) {
            if (grid[i][j] !== start && grid[i][j] !== end) {
                grid[i][j].wall = !grid[i][j].wall;
                if(isFinished) init(); else draw();
            }
        }
    });

    function resetGrid() {
        init();
    }

    // åˆå§‹åŒ–
    init();

</script>
</body>
</html>